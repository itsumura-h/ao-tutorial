# ã‚¢ãƒªãƒ¼ãƒŠã®ãƒ¡ã‚«ãƒ‹ã‚¯ã‚¹

ã“ã®ã‚¬ã‚¤ãƒ‰ã§ã¯ã€`aos`ã§ã‚¢ãƒªãƒ¼ãƒŠã‚¹ã‚¿ã‚¤ãƒ«ã®ã‚²ãƒ¼ãƒ ã‚’è¨­è¨ˆãŠã‚ˆã³ç®¡ç†ã™ã‚‹ãŸã‚ã«å¿…è¦ãªåŸºæœ¬çš„ãªãƒ¡ã‚«ãƒ‹ã‚¯ã‚¹ã®åŒ…æ‹¬çš„ãªæ¦‚è¦ã‚’æä¾›ã—ã¾ã™ã€‚ã‚¢ãƒªãƒ¼ãƒŠã‚²ãƒ¼ãƒ ã§ã¯ã€å‚åŠ è€…ã¯ãƒ©ã‚¦ãƒ³ãƒ‰ã”ã¨ã«æˆ¦ç•¥çš„ã«ç«¶ã„åˆã„ã€æœ€å¾Œã®å‹è€…ãŒæ®‹ã‚‹ã¾ã§ç›¸æ‰‹ã‚’æ’é™¤ã—ã¾ã™ã€‚

ã“ã“ã§ç´¹ä»‹ã™ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã¯ã€åŒã˜åŸºæœ¬æ©Ÿèƒ½ã‚’å…±æœ‰ã™ã‚‹ã•ã¾ã–ã¾ãªã‚²ãƒ¼ãƒ ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã®åŸºç›¤ã‚’æä¾›ã—ã¾ã™ã€‚ã‚²ãƒ¼ãƒ é–‹ç™ºã®è©³ç´°ã‚’æ¢æ±‚ã—ã€ã“ã®å¤šç”¨é€”ã®ã‚¢ãƒªãƒ¼ãƒŠå†…ã§å‰µé€ åŠ›ã‚’ç™ºæ®ã—ã¾ã—ã‚‡ã†ã€‚

## åŸºæœ¬æ©Ÿèƒ½

ã‚¢ãƒªãƒ¼ãƒŠã‚¹ã‚¿ã‚¤ãƒ«ã®ã‚²ãƒ¼ãƒ ã‚’æ”¯ãˆã‚‹åŸºæœ¬æ©Ÿèƒ½ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ï¼š

1. **ã‚²ãƒ¼ãƒ é€²è¡Œãƒ¢ãƒ¼ãƒ‰ï¼š**

ã‚¢ãƒªãƒ¼ãƒŠã‚²ãƒ¼ãƒ ã¯ãƒ©ã‚¦ãƒ³ãƒ‰ã”ã¨ã«æ§‹é€ åŒ–ã•ã‚Œã¦ãŠã‚Šã€æ¬¡ã®é€²è¡Œãƒ¢ãƒ¼ãƒ‰ãŒãƒ«ãƒ¼ãƒ—ã—ã¾ã™ï¼š `"Not-Started"` â†’ `"Waiting"` â†’ `"Playing"` â†’ `[èª°ã‹ãŒå‹ã¤ã‹ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ]` â†’ `"Waiting"`...

> [!æ³¨æ„]
> å¾…æ©ŸçŠ¶æ…‹å¾Œã«ååˆ†ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã„ãªã„å ´åˆã€ãƒ«ãƒ¼ãƒ—ã¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã™ã€‚

ãƒ©ã‚¦ãƒ³ãƒ‰ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå‚åŠ ã™ã‚‹ãŸã‚ã®å®šç¾©ã•ã‚ŒãŸæ™‚é–“æ ã‚’æä¾›ã—ã€ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã®èˆˆå¥®ã‚’å¢—å¹…ã•ã›ã¾ã™ã€‚

2. **ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ†ãƒ¼ã‚¯ï¼š**

ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ã‚²ãƒ¼ãƒ ã«å‚åŠ ã™ã‚‹ãŸã‚ã«æŒ‡å®šã•ã‚ŒãŸæ•°é‡ã®ãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆ`PaymentQty`ã§å®šç¾©ï¼‰ã‚’ãƒ‡ãƒã‚¸ãƒƒãƒˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒˆãƒ¼ã‚¯ãƒ³ã¯ã‚²ãƒ¼ãƒ ã«å®Ÿè³ªçš„ãªã‚¹ãƒ†ãƒ¼ã‚¯è¦ç´ ã‚’è¿½åŠ ã—ã¾ã™ã€‚

3. **ãƒœãƒ¼ãƒŠã‚¹å ±é…¬ï¼š**

å‹åˆ©ã®ã‚¹ãƒªãƒ«ã‚’è¶…ãˆã¦ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯è¿½åŠ ã®å ±é…¬ã®å¯èƒ½æ€§ã«å¼•ãä»˜ã‘ã‚‰ã‚Œã¾ã™ã€‚ãƒ“ãƒ«ãƒ€ãƒ¼ã¯ã€ãƒ©ã‚¦ãƒ³ãƒ‰ã”ã¨ã«åˆ†é…ã•ã‚Œã‚‹ãƒœãƒ¼ãƒŠã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆ`BonusQty`ã§å®šç¾©ï¼‰ã‚’æä¾›ã™ã‚‹æŸ”è»Ÿæ€§ã‚’æŒã¡ã¾ã™ã€‚ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè¡Œã£ãŸãƒ™ãƒƒãƒˆã‚‚ã“ã‚Œã‚‰ã®ãƒœãƒ¼ãƒŠã‚¹ã«è¿½åŠ ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒœãƒ¼ãƒŠã‚¹ã¯è¿½åŠ ã®ã‚¤ãƒ³ã‚»ãƒ³ãƒ†ã‚£ãƒ–ã¨ãªã‚Šã€ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã®ç«¶äº‰ç²¾ç¥ã‚’é«˜ã‚ã¾ã™ã€‚

4. **ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†ï¼š**

- æ¬¡ã®ã‚²ãƒ¼ãƒ ã«å‚åŠ ã‚’å¾…ã£ã¦ã„ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯`Waiting`ãƒ†ãƒ¼ãƒ–ãƒ«ã§è¿½è·¡ã•ã‚Œã¾ã™ã€‚
- ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ãã®ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã¯`Players`ãƒ†ãƒ¼ãƒ–ãƒ«ã«ä¿å­˜ã•ã‚Œã¾ã™ã€‚
- æ’é™¤ã•ã‚ŒãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ã™ãã«`Players`ãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰å‰Šé™¤ã•ã‚Œã€æ¬¡ã®ã‚²ãƒ¼ãƒ ã®ãŸã‚ã«`Waiting`ãƒ†ãƒ¼ãƒ–ãƒ«ã«é…ç½®ã•ã‚Œã¾ã™ã€‚

5. **ãƒ©ã‚¦ãƒ³ãƒ‰å‹è€…ã®å ±é…¬ï¼š**

ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒä»–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ’é™¤ã™ã‚‹ã¨ã€å‹è€…ã¯è‡ªåˆ†ã®ã‚ªãƒªã‚¸ãƒŠãƒ«ã®ã‚¹ãƒ†ãƒ¼ã‚¯ã«åŠ ãˆã¦ã€æ’é™¤ã•ã‚ŒãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ‡ãƒã‚¸ãƒƒãƒˆãƒˆãƒ¼ã‚¯ãƒ³ã‚’å ±é…¬ã¨ã—ã¦å—ã‘å–ã‚Šã¾ã™ã€‚ã•ã‚‰ã«ã€å„ãƒ©ã‚¦ãƒ³ãƒ‰ã®å‹è€…ã¯ãƒœãƒ¼ãƒŠã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã®ä¸€éƒ¨ã‚‚åˆ†é…ã•ã‚Œã¾ã™ã€‚

6. **ãƒªã‚¹ãƒŠãƒ¼ãƒ¢ãƒ¼ãƒ‰ï¼š**

ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«å‚åŠ ã™ã‚‹ã®ã§ã¯ãªãã€ã‚²ãƒ¼ãƒ ã®é€²è¡Œã‚’è¦‹å®ˆã‚ŠãŸã„äººã«ã¯ã€Œãƒªã‚¹ãƒŠãƒ¼ã€ãƒ¢ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚ãƒ—ãƒ­ã‚»ã‚¹ã¯ãƒªã‚¹ãƒŠãƒ¼ã¨ã—ã¦ç™»éŒ²ã•ã‚Œã€ã‚²ãƒ¼ãƒ ã®ã™ã¹ã¦ã®ã‚¢ãƒŠã‚¦ãƒ³ã‚¹ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã—ã¦å‚åŠ ã—ãªã„å ´åˆã§ã‚‚ã€æ˜ç¤ºçš„ã«å‰Šé™¤ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆã—ãªã„é™ã‚Šã€ã‚²ãƒ¼ãƒ ã®é€²è¡Œã‚’è¦³å¯Ÿã—ç¶šã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

7. **ã‚²ãƒ¼ãƒ çŠ¶æ…‹ç®¡ç†ï¼š**

ã‚¢ãƒªãƒ¼ãƒŠã‚²ãƒ¼ãƒ ã®æµã‚Œã¨å…¬å¹³æ€§ã‚’ç¶­æŒã™ã‚‹ãŸã‚ã«ã€è‡ªå‹•åŒ–ã‚·ã‚¹ãƒ†ãƒ ãŒã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®é·ç§»ã‚’ç›£è¦–ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®é·ç§»ã¯ã€å¾…æ©Ÿã€ãƒ—ãƒ¬ã‚¤ã€çµ‚äº†ãƒ•ã‚§ãƒ¼ã‚ºã‚’å«ã¿ã¾ã™ã€‚å„çŠ¶æ…‹ã®æ™‚é–“ï¼ˆ`WaitTime`ãŠã‚ˆã³`GameTime`ï¼‰ã¯ã€ãƒ©ã‚¦ãƒ³ãƒ‰ãŒç„¡æœŸé™ã«ç¶šã‹ãªã„ã‚ˆã†ã«å®šç¾©ã•ã‚ŒãŸæ™‚é–“æ ã«å¾“ã†ã“ã¨ã‚’ä¿è¨¼ã—ã¾ã™ã€‚

ã‚¢ãƒªãƒ¼ãƒŠã®ã‚³ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã®ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã§ç¢ºèªã§ãã¾ã™ï¼š

<details>
  <summary><strong>ã‚¢ãƒªãƒ¼ãƒŠã‚²ãƒ¼ãƒ ã®ãƒ–ãƒ«ãƒ¼ãƒ—ãƒªãƒ³ãƒˆ</strong></summary>

```lua
-- ARENA GAME BLUEPRINT.

-- This blueprint provides the framework to operate an 'arena' style game
-- inside an ao process. Games are played in rounds, where players aim to
-- eliminate one another until only one remains, or until the game time
-- has elapsed. The game process will play rounds indefinitely as players join
-- and leave.

-- When a player eliminates another, they receive the eliminated player's deposit token
-- as a reward. Additionally, the builder can provide a bonus of these tokens
-- to be distributed per round as an additional incentive. If the intended
-- player type in the game is a bot, providing an additional 'bonus'
-- creates an opportunity for coders to 'mine' the process's
-- tokens by competing to produce the best agent.

-- The builder can also provide other handlers that allow players to perform
-- actions in the game, calling 'eliminatePlayer()' at the appropriate moment
-- in their game logic to control the framework.

-- Processes can also register in a 'Listen' mode, where they will receive
-- all announcements from the game, but are not considered for entry into the
-- rounds themselves. They are also not unregistered unless they explicitly ask
-- to be.

-- GLOBAL VARIABLES.

-- Game progression modes in a loop:
-- [Not-Started] -> Waiting -> Playing -> [Someone wins or timeout] -> Waiting...
-- The loop is broken if there are not enough players to start a game after the waiting state.
GameMode = GameMode or "Not-Started"
StateChangeTime = StateChangeTime or undefined

-- State durations (in milliseconds)
WaitTime = WaitTime or 2 * 60 * 1000 -- 2 minutes
GameTime = GameTime or 20 * 60 * 1000 -- 20 minutes
Now = Now or undefined -- Current time, updated on every message.

-- Token information for player stakes.
UNIT = 1000
PaymentToken = PaymentToken or "ADDR"  -- Token address
PaymentQty = PaymentQty or tostring(math.floor(UNIT))    -- Quantity of tokens for registration
BonusQty = BonusQty or tostring(math.floor(UNIT))        -- Bonus token quantity for winners

-- Players waiting to join the next game and their payment status.
Waiting = Waiting or {}
-- Active players and their game states.
Players = Players or {}
-- Number of winners in the current game.
Winners = 0
-- Processes subscribed to game announcements.
Listeners = Listeners or {}
-- Minimum number of players required to start a game.
MinimumPlayers = MinimumPlayers or 2

-- Default player state initialization.
PlayerInitState = PlayerInitState or {}

-- Sends a state change announcement to all registered listeners.
-- @param event: The event type or name.
-- @param description: Description of the event.
function announce(event, description)
    for ix, address in pairs(Listeners) do
        ao.send({
            Target = address,
            Action = "Announcement",
            Event = event,
            Data = description
        })
    end
    return print(Colors.gray .. "Announcement: " .. Colors.red .. event .. " " .. Colors.blue .. description .. Colors.reset)
end

-- Sends a reward to a player.
-- @param recipient: The player receiving the reward.
-- @param qty: The quantity of the reward.
-- @param reason: The reason for the reward.
function sendReward(recipient, qty, reason)
    if type(qty) ~= number then
      qty = tonumber(qty)
    end
    ao.send({
        Target = PaymentToken,
        Action = "Transfer",
        Quantity = tostring(qty),
        Recipient = recipient,
        Reason = reason
    })
    return print(Colors.gray .. "Sent Reward: " ..
      Colors.blue .. tostring(qty) ..
      Colors.gray .. ' tokens to ' ..
      Colors.green .. recipient .. " " ..
      Colors.blue .. reason .. Colors.reset
    )
end

-- Starts the waiting period for players to become ready to play.
function startWaitingPeriod()
    GameMode = "Waiting"
    StateChangeTime = Now + WaitTime
    announce("Started-Waiting-Period", "The game is about to begin! Send your token to take part.")
    print('Starting Waiting Period')
end

-- Starts the game if there are enough players.
function startGamePeriod()
    local paidPlayers = 0
    for player, hasPaid in pairs(Waiting) do
        if hasPaid then
            paidPlayers = paidPlayers + 1
        end
    end

    if paidPlayers < MinimumPlayers then
        announce("Not-Enough-Players", "Not enough players registered! Restarting...")
        for player, hasPaid in pairs(Waiting) do
            if hasPaid then
                Waiting[player] = false
                sendReward(player, PaymentQty, "Refund")
            end
        end
        startWaitingPeriod()
        return
    end

    LastTick = undefined
    GameMode = "Playing"
    StateChangeTime = Now + GameTime
    for player, hasPaid in pairs(Waiting) do
        if hasPaid then
            Players[player] = playerInitState()
       

 else
            ao.send({
                Target = player,
                Action = "Ejected",
                Reason = "Did-Not-Pay"
            })
            removeListener(player) -- Removing player from listener if they didn't pay
        end
    end
    announce("Started-Game", "The game has started. Good luck!")
    print("Game Started....")
end

-- Handles the elimination of a player from the game.
-- @param eliminated: The player to be eliminated.
-- @param eliminator: The player causing the elimination.
function eliminatePlayer(eliminated, eliminator)
    sendReward(eliminator, PaymentQty, "Eliminated-Player")
    Waiting[eliminated] = false
    Players[eliminated] = nil

    ao.send({
        Target = eliminated,
        Action = "Eliminated",
        Eliminator = eliminator
    })

    announce("Player-Eliminated", eliminated .. " was eliminated by " .. eliminator .. "!")

    local playerCount = 0
    for player, _ in pairs(Players) do
        playerCount = playerCount + 1
    end
    print("Eliminating player: " .. eliminated .. " by: " .. eliminator) -- Useful for tracking eliminations

    if playerCount < MinimumPlayers then
        endGame()
    end

end

-- Ends the current game and starts a new one.
function endGame()
    print("Game Over")

    Winners = 0
    Winnings = tonumber(BonusQty) / Winners -- Calculating winnings per player

    for player, _ in pairs(Players) do
        Winners = Winners + 1
    end

    Winnings = tonumber(BonusQty) / Winners

    for player, _ in pairs(Players) do
        -- addLog("EndGame", "Sending reward of:".. Winnings + PaymentQty .. "to player: " .. player) -- Useful for tracking rewards
        sendReward(player, Winnings + tonumber(PaymentQty), "Win")
        Waiting[player] = false
    end

    Players = {}
    announce("Game-Ended", "Congratulations! The game has ended. Remaining players at conclusion: " .. Winners .. ".")
    startWaitingPeriod()
end

-- Removes a listener from the listeners' list.
-- @param listener: The listener to be removed.
function removeListener(listener)
    local idx = 0
    for i, v in ipairs(Listeners) do
        if v == listener then
            idx = i
            break
        end
    end
    if idx > 0 then
        table.remove(Listeners, idx)
    end
end

-- HANDLERS: Game state management

-- Handler for cron messages, manages game state transitions.
Handlers.add(
    "Game-State-Timers",
    function(Msg)
        return "continue"
    end,
    function(Msg)
        Now = Msg.Timestamp
        if GameMode == "Not-Started" then
            startWaitingPeriod()
        elseif GameMode == "Waiting" then
            if Now > StateChangeTime then
                startGamePeriod()
            end
        elseif GameMode == "Playing" then
            if onTick and type(onTick) == "function" then
              onTick()
            end
            if Now > StateChangeTime then
                endGame()
            end
        end
    end
)

-- Handler for player deposits to participate in the next game.
Handlers.add(
    "Transfer",
    function(Msg)
        return
            Msg.Action == "Credit-Notice" and
            Msg.From == PaymentToken and
            tonumber(Msg.Quantity) >= tonumber(PaymentQty) and "continue"
    end,
    function(Msg)
        Waiting[Msg.Sender] = true
        ao.send({
            Target = Msg.Sender,
            Action = "Payment-Received"
        })
        announce("Player-Ready", Msg.Sender .. " is ready to play!")
    end
)

-- Registers new players for the next game and subscribes them for event info.
Handlers.add(
    "Register",
   { Action = "Register" },
    function(Msg)
        if Msg.Mode ~= "Listen" and Waiting[Msg.From] == undefined then
            Waiting[Msg.From] = false
        end
        removeListener(Msg.From)
        table.insert(Listeners, Msg.From)
        ao.send({
            Target = Msg.From,
            Action = "Registered"
        })
        announce("New Player Registered", Msg.From .. " has joined in waiting.")
    end
)

-- Unregisters players and stops sending them event info.
Handlers.add(
    "Unregister",
   { Action = "Unregister" },
    function(Msg)
        removeListener(Msg.From)
        ao.send({
            Target = Msg.From,
            Action = "Unregistered"
        })
    end
)

-- Adds bet amount to BonusQty
Handlers.add(
    "AddBet",
    { Reason = "AddBet" },
    function(Msg)
        BonusQty = tonumber(BonusQty) + tonumber(Msg.Tags.Quantity)
        announce("Bet-Added", Msg.From .. "has placed a bet. " .. "BonusQty amount increased by " .. Msg.Tags.Quantity .. "!")
    end
)

-- Retrieves the current game state.
Handlers.add(
    "GetGameState",
   { Action = "GetGameState" },
    function (Msg)
        local json = require("json")
        local TimeRemaining = StateChangeTime - Now
        local GameState = json.encode({
            GameMode = GameMode,
            TimeRemaining = TimeRemaining,
            Players = Players,
            })
        ao.send({
            Target = Msg.From,
            Action = "GameState",
            Data = GameState})
    end
)

-- Alerts users regarding the time remaining in each game state.
Handlers.add(
    "AnnounceTick",
   { Action = "Tick" },
    function (Msg)
        local TimeRemaining = StateChangeTime - Now
        if GameMode == "Waiting" then
            announce("Tick", "The game will start in " .. (TimeRemaining/1000) .. " seconds.")
        elseif GameMode == "Playing" then
            announce("Tick", "The game will end in " .. (TimeRemaining/1000) .. " seconds.")
        end
    end
)

-- Sends tokens to players with no balance upon request
Handlers.add(
    "RequestTokens",
   { Action = "RequestTokens" },
    function (Msg)
        print("Transfering Tokens: " .. tostring(math.floor(10000 * UNIT)))
        ao.send({
            Target = ao.id,
            Action = "Transfer",
            Quantity = tostring(math.floor(10000 * UNIT)),
            Recipient = Msg.From,
        })
    end
)
```

</details>

## ã‚¢ãƒªãƒ¼ãƒŠã‚²ãƒ¼ãƒ ã®ãƒ–ãƒ«ãƒ¼ãƒ—ãƒªãƒ³ãƒˆ

ã“ã®ã‚¢ãƒªãƒ¼ãƒŠãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’ä½¿ç”¨ã—ãŸã„æ–¹ã®ãŸã‚ã«ã€ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’ãƒ–ãƒ«ãƒ¼ãƒ—ãƒªãƒ³ãƒˆã¨ã—ã¦ç°¡å˜ã«åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã§æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã ã‘ã§ã™ï¼š

```lua
.load-blueprint arena
```

## ã¾ã¨ã‚

ã‚¢ãƒªãƒ¼ãƒŠã®ãƒ¡ã‚«ãƒ‹ã‚¯ã‚¹ã‚’ç†è§£ã™ã‚‹ã“ã¨ã§ã€å‰ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ä½œæˆã—ãŸè‡ªå¾‹ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’æ”¹å–„ã™ã‚‹ã ã‘ã§ãªãã€ã“ã®åŸºæœ¬æ©Ÿèƒ½ã‚’æ´»ç”¨ã—ã¦ç‹¬è‡ªã®ã‚²ãƒ¼ãƒ ã‚’æ§‹ç¯‰ã™ã‚‹èƒ½åŠ›ã‚‚èº«ã«ä»˜ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

æ¬¡ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã€Œã‚²ãƒ¼ãƒ ã®æ§‹ç¯‰ã€ã§ã¯ã€ã“ã‚Œã‚‰ã®ãƒ¡ã‚«ãƒ‹ã‚¯ã‚¹ã‚’æ´»ç”¨ã—ã¦ã€ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯å†…ã§é­…åŠ›çš„ã§ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªã‚²ãƒ¼ãƒ ã‚’æ§‹ç¯‰ã™ã‚‹æ–¹æ³•ã«ã¤ã„ã¦è©³ã—ãèª¬æ˜ã—ã¾ã™ã€‚ã‚²ãƒ¼ãƒ é–‹ç™ºã®ãƒ€ã‚¤ãƒŠãƒŸãƒƒã‚¯ãªä¸–ç•Œã«é£›ã³è¾¼ã‚€æº–å‚™ã¯ã§ãã¦ã„ã¾ã™ã‹ï¼Ÿ ğŸ®
